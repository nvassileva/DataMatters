#!/usr/bin/env python3
# coding: utf-8

"""
This work is licensed under CC BY 4.0. 
To view a copy of this license, visit https://creativecommons.org/licenses/by/4.0/



Updated in July and August 2024

Generating data sets from PeMS data (Caltran)

Generates data for a base station (BS): used 
to initiate new calls (service connections) in the target BS and 
to track the number of handover calls per time slot to the subsequent, 
neighbouring BS as well as the remaining time of the handover calls. 
A highway scenario with unidirectional traffic is assumed, where the BSs 
are sequentially ordered (one neighbouring BS on each side of  
the 'target' BS except for the first and last BSs). This program gnerates 
mobile cellular call related data for the very first BS on the highway.
The flow and speed metrics are assumed to be measured outside yet in the 
vicinity of the BS. Each row of data contains the flow and speed in time
slot 't' near but outside the BS and the calls observed during the same 
time interval 't' in the BS. The flow and speed in time slot 't' (measured
outside the taget BS) are those observed during time slot 't+1' in the BS.   
Number of calls are generated per vehicle following a Poisson distribution. 
The call duration is sampled from a probability distribution.


@author: vesseln1
"""

__title__			 = 'Mobile traffic forecasting'
__description__		 = 'Generates mobile traffic load on a highway.'
__version__			 = '2.0.0'
__date__			 = 'July 2024'
__author__			 = 'Natalia Vesselinova'
__author_email__	 = 'natalia.vesselinova@aalto.fi'
__institution__ 	 = 'Alto University'
__department__		 = 'Mathematics and Systems Analysis'
__url__				 = 'https://github.com/nvassileva/DataMatters/'
__license__          = 'CC BY 4.0'


# Import the necessary packages
import os
import argparse
import datetime
import numpy as np
import pandas as pd
import ruamel.yaml
yaml = ruamel.yaml.YAML()

# Parse command-line options, arguments and sub-commands
parser = argparse.ArgumentParser()
parser.add_argument('--dataRoot', '-d', required=True, type=str, help='Path to directory with the data.')
parser.add_argument('--outputRoot', '-o',  required=True, type=str, help='Path to the output directory with the generated data.')
parser.add_argument('--distance', '-m', required=True, type=float, help='The range of the base station in miles.')
parser.add_argument('--distribution', '-distr', required=True, type=int, help='Call distribution (an int): 1:exponential, 2:lognormal, 3:a mixture of two lognormals')
parser.add_argument('--arrivalRate', '-a', type=int, help='Call interarrival rate of a Poisson process', default=1)
parser.add_argument('--meanCallDuration', '-c1', type=float, help='Mean call duration', default=1)
parser.add_argument('--timeInterval', type=int, help='PeMS time granularity in minutes', default=5)
parser.add_argument('--standardDeviationCallDuration', '-std1', type=float, help='Standard deviation of the call duration distribution', default=np.sqrt(3))
parser.add_argument('--probability', '-p', type=float, help='Probability parameter (fairness/bias) in the mixture of two lognormals PDF', default=0.5)
parser.add_argument('--meanCallDuration2', '-c2',  type=float, help='Mean call duration in minutes for the second lognormal in the mixture of 2 lognorm distr', default=1)
parser.add_argument('--standardDeviationCallDuration2', '-std2', type=float, help='Standard deviation of the call duration distribution of the second lognormal in the mixture of 2 lognormal distr', default=np.sqrt(3))
parser.add_argument('--maxCalls', type= int, help='Needed for coding purposes', default=100)
parser.add_argument('--beginWeek', '-b', type=int, help='The first week with data', default=13)
parser.add_argument('--endWeek', '-e', type=int, help='Week number of the last week with data.', default=36)
args = parser.parse_args()



dataRoot    = args.dataRoot
outputR     = args.outputRoot
timeInt     = args.timeInterval
distance    = args.distance
distr       = args.distribution
rateArr     = args.arrivalRate             
meanCallD   = args.meanCallDuration               
stdDevCallD = args.standardDeviationCallDuration
prob        = args.probability             
meanCallD2  = args.meanCallDuration2
stdDevCallD2= args.standardDeviationCallDuration2  
maxCalls    = args.maxCalls
beginWeek   = args.beginWeek
endWeek     = args.endWeek


# Convert the arguments into a dictionary to save them in yaml file later on 
argsDict = vars(args)



# Vehicular arrival traffic: emulating a Poisson process 
def vehFlow(flow, timeI
            ):
    """ Emulating the arrival times of the vehicles
        using the real data measurements from PeMS and 
        assuming Poisson arrival process with mean=flow/timeI.
        The Poisson arrival process is generated by 
        exponentially distributed interarrival times with mean=timeI/flow.
        
        Returns an numpy array with ordered intearrival times.
    """
    expArrT = np.random.exponential(timeI/flow, flow)

    for i in range(1, len(expArrT)):
        expArrT[i] += expArrT[i - 1]
    
    while not expArrT[-1] < float(timeI):
        timeI -= 0.05
        expArrT = np.random.exponential(timeI/flow, flow)

        for i in range(1, len(expArrT)):
            expArrT[i] += expArrT[i - 1]
    
    return expArrT



# Vehicular dwell time in the cell: calculation
def dwellTime(speed, distance, flow, noiseMean=0, noiseStd=0.05
              ):
    ''' Calculates the dwell time of the vehicle in the cell
        using the PeMS average speed (reported per flow for 5-minute intervals) 
        and the range of the BS measured in miles (or km).
        BS range refers to the fraction of the highway served by 
        the target BS (the BS for which the data is generated).
        
        Input: flow:      PeMS flow (Caltrans measurement)
               speed:     PeMS average vehicular speed per 5-minute-interval 
                          (a univariate or a list) 
                distance: user defined (the BS range in miles)
                noiseMean and noiseStd of normal distribution to make 
                the dwellTime non-deterministic 
                (under the same speed and distance values). The default noise 
                (mean=0 and std=0.05) means that 
                the r.v. belongs to [-0.15, 0.15] with prob = 0.997.
        
        Returns the average dwell times of vehicles in the BS for 
                a specific 5-minute-interval, speed and distance.
    '''
    speed = np.array(speed) 
    speed[speed==0] = 1     # to avoid division by 0; this does not change the end results as speed is discretised
    
    avDwellT = (distance / speed) * 60
    dwellT = abs(np.random.normal(noiseMean, noiseStd, flow) + avDwellT)
    
    return dwellT



# Generating new call arrivals
def callNewGen(rateArr, timeInt, maxCalls
            ):
    ''' Generate (new) call requests per vehicle (indVeh)
        emulating Poisson arrivals at the vehicle with rateArr. 
        This requests are generated upon the vehicle's arrival
        at each BS. In other words, the process of generating calls
        is repeated at each BS.
        
        maxCalls is to know how many to generate at most yet
        the exact number of calls depends on the Poisson 
        rateArr and on the veh dwell time.
        
        Return the number of call arrival time(s). 
    '''  
    # Create an exception when the max calls is not a positive integer
    # to notify that this is not an accepted value
    if maxCalls < 0 or rateArr <= 0:  
        print('Enter valid values for the arrival rate and maxCalls. ')
        raise ValueError('The arrival rate must be positive and maxCalls non-negative!')

    # Create an array with call arrival times   
    callArrTimeNew = np.random.exponential((timeInt/rateArr), (maxCalls))
    for t in range(1, len(callArrTimeNew)):
        callArrTimeNew[t] += callArrTimeNew[t - 1]   # Poisson process / exp interarrival times
    
    return callArrTimeNew



# Lognormal distribution parameters from the mean and variance 
def lognormal_parameters(mean, std
            ):
    """ Determine the parameters of the lognormal distribution 
        mu_lognorm and sigma_lognorm
        from the mean and variance of the lognormal distribution.
        
        Returns mu_lognorm and sigma_lognorm.
    
    """
    sigma_lognorm = np.sqrt(np.log(1 + np.square(std)/np.square(mean)))
    mu_lognorm = np.log(np.square(mean) / np.sqrt(np.square(std) + np.square(mean)))
    
    return mu_lognorm, sigma_lognorm



# Call duration -- exponential, lognormal or a mixture of two lognormals
def callDuration(numCalls, distr, meanCallD, stdDevCallD, meanCallD2, stdDevCallD2, probability
            ):
    ''' Generate the call duration.
        
        Input: 
            numCalls := the total number of calls to be generated  
            distr    := the probability distribution from which to sample
                          1: exponential
                          2: lognormal
                          3: mixture of two lognormals
        
        Return call duration array. 
    '''
    if meanCallD <= 0 or meanCallD2 <= 0:
        raise ValueError("Clearly, the mean call duration can only be positive!")
        
    if distr == 1:
        callD = np.random.exponential(meanCallD, numCalls)
    if distr == 2:
        mu_lognorm, sigma_lognorm = lognormal_parameters(meanCallD, stdDevCallD)
        callD = np.random.lognormal(mu_lognorm, sigma_lognorm, numCalls)
    if distr == 3:
        mu_lognorm, sigma_lognorm = lognormal_parameters(meanCallD, stdDevCallD)
        mu_lognorm2, sigma_lognorm2 = lognormal_parameters(meanCallD2, stdDevCallD2)
        callD = np.zeros(0)
        # flip a coin with parameter prob for each call
        for _ in range(numCalls):
            if np.random.random() < probability:
                callD = np.append(callD, np.random.lognormal(mu_lognorm, sigma_lognorm))
            else:
                callD = np.append(callD, np.random.lognormal(mu_lognorm2, sigma_lognorm2))
       
    return callD


# Determine the call type and the timeslot it belongs to
def callClass(timeInt, callArrT, vehArrT, vehDepT, 
              distr, meanCallD, stdDevCallD, meanCallD2, stdDevCallD2, probability
            ):
    ''' Determine the call type -- 'new' or 'handover' -- and the timeslot 
        it belongs to.
    
        callArrT:  call arrival times (an array)
        vehArrT:   vehicule's arrival time (a const)
                    needed for shifting the call arr times
        vehDepT:   vehicle's departure time (a const)
                    to determine the class of the call,
                    either new of handover
        meanCallD: mean call duration (a const)
        
        Return 3 arrays: the number of new calls per time slot,
        the number of handover calls (if any) per time slot
        and their (HO's) remaining (excess) times (a list). 
    ''' 
    # Create an array of size four
    # arr[0] accounts for num calls during TS0 
    # arr[1] for calls initiated by the veh 
    # while in the coverage of the BS but during TS1, 
    # i.e., the next 5-min slot; continue up to TS3
    newCalls = np.zeros(4)
    callsHO = np.zeros(4)

    # An array for keeping track of the excess time
    # per each time slot TS0 to TS3
    # Excess time refers to the remaining call duration
    # when the vehicle has left the BS (and entered the service area of the 
    # neighbouring BS.
    excessT0 = np.empty([0])
    excessT1 = np.empty([0])
    excessT2 = np.empty([0])
    excessT3 = np.empty([0])
   
    # Shift call arrivals with the time of the vehicle's arrival
    callArrT += vehArrT
    
    # Generate the duration of the calls  
    # callEndT contains the time instants when the calls end
    callEndT = callDuration(len(callArrT), distr, meanCallD, stdDevCallD, meanCallD2, stdDevCallD2, probability) + callArrT  
    
    # Which time slot do the calls belolong to?
    for call, arrT in enumerate(callArrT):
        if arrT > vehDepT:
            break
        # determine the time slot the new call belongs to
        if arrT <= timeInt: 
            newCalls[0] += 1
        elif arrT > timeInt and arrT <= 2*timeInt:
            newCalls[1] += 1
        elif arrT > 2*timeInt and arrT <= 3*timeInt: 
            newCalls[2] += 1
        elif arrT > 3*timeInt:
            newCalls[3] += 1
        
        # determine the time slot the handover call belongs to
        if callEndT[call] > vehDepT:
            if vehDepT <= timeInt:
                callsHO[0] += 1
                excessT0 = np.append(excessT0, callEndT[call] - vehDepT)
            elif vehDepT > timeInt and vehDepT <= 2*timeInt:
                callsHO[1] += 1
                excessT1 = np.append(excessT1, callEndT[call] - vehDepT)
            elif vehDepT > 2*timeInt and vehDepT <= 3*timeInt:
                callsHO[2] += 1
                excessT2 = np.append(excessT2, callEndT[call] - vehDepT)
            elif vehDepT > 3*timeInt:
                callsHO[3] += 1
                excessT3 = np.append(excessT3, callEndT[call] - vehDepT)
        
    excessT = [excessT0, excessT1, excessT2, excessT3] 
                    
    return newCalls, callsHO, excessT



# Convert the averaged speed into a speed level
def speedConv(speed
              ):
    """ The PeMS averaged speed is converted into speed levels as such discretisation
        decreases the prediction error. The discretisation is conducted 
        at the very end, after all calculations that involve the speed are done.        
        The MAE was decreased by 2 % by discretising the speed alone
        for the very first case study (the patent).       
    """
    speedLevel = []
    for speedV in speed:
        if speedV < 20:
            speedLevel.append(1)
        elif speedV >= 20 and speedV < 25:
            speedLevel.append(2)
        elif speedV >= 25 and speedV < 30:
            speedLevel.append(3)
        elif speedV >= 30 and speedV < 35:
            speedLevel.append(4)
        elif speedV >= 35 and speedV < 40:
            speedLevel.append(5)
        elif speedV >= 40 and speedV < 50:
            speedLevel.append(6)
        elif speedV >= 50 and speedV < 60:
            speedLevel.append(7)
        else: 
            speedLevel.append(8)
          
    return speedLevel




# Data generation 
def dataProcessing(file): 
    ''' Reads road statistics relevant to the current BS to obtain
        network statistics for this BS (the target BS)
    
        Input:  file:    Reads data from a PeMS file and generates the  
                          network service requests (calls) and needed statistics.
        
        Returns 3 pandas dataframes:
                dataML:  the input to the ML model: Flow, Speed Level, Total Num Calls = Total New Calls + Total HOs
                data:    Time, Flow, Speed, Total New Calls, Total HOs from the current, target BS (BS1) to the next BS (BS2)
                          (BS1 to BS2 Total HOs together with their corresponding Remaining Time array 
                          are used in BS3 net metrics generation. Time, Flow, and Speed are PeMS data.)
                dataRT:  an array with the HOs' Remaining Time per five-minute time interval
        '''  
    # Read from a PeMS Excel file
    data = pd.read_excel(file, header=0, usecols=['5 Minutes', 'Flow (Veh/5 Minutes)', 'Speed (mph)'])
    numM = data.shape[0]

    # In case more data was downloaded from the earlier day (Sunday), 
    # some will be removed. 
    # The first record will be from Sunday 23:55 h and
    # the last from Friday 23:55 h
    if numM > 1441:
        data.drop(data.head(11).index,inplace=True)    # remove the first eleven rows corresponding to Sunday from 23:00 h to 23:50 h
        data = data.assign(Index=range(len(data))).set_index('Index')
    numM = data.shape[0]
   
        

    # Add network variables to the data frame 'data'
    data.loc[:, ['Total New Calls', 'Total HO Calls']] = 0
    # Extend by 4 rows: the first row is needed because we read flow and speed
    # measured in time slot 't'. Network metrics in 't+1' are generated based
    # on them.
    # We also make computations (generate data) for 3 TSs ahead in case
    # the vehicle is still within the BS coverage and requests BS service (makes calls).
    for i in range(4):
        data.loc[len(data.index)] = [0, 0, 0, 0, 0]  
    
    # Create a data frame for the HO calls remaining time
    dataRT = pd.DataFrame(columns=['Five-Minute Time Interval Index', '(Next BS) Remaining Time'])
        
    # Generate the network statistic for BS1 
    for row in range(numM):
        if data.at[row, 'Flow (Veh/5 Minutes)'] != 0:
            indA = np.arange(1, data.at[row, 'Flow (Veh/5 Minutes)'] + 1).astype(int)
            df = pd.DataFrame(indA, columns=['Total Num Veh'])

            flow = int(data.at[row, 'Flow (Veh/5 Minutes)'])  
            speed = data.at[row, 'Speed (mph)']

            df['Veh Arr Time'] = vehFlow(flow, timeInt) 
            df['Veh Dwell Time'] = dwellTime(speed, distance, flow)
            df['Veh Dep Time'] = df['Veh Arr Time'] + df['Veh Dwell Time']  
            
            # Create an auxiliary data frame for saving the call remaining times
            # from all vehicles during a five-minute interval
            dfRT = pd.DataFrame(columns=['Five-Minute Time Interval Index', '(Next BS) Remaining Time'])  

            for veh in range(flow):
                callArrT = callNewGen(rateArr, timeInt, maxCalls)
                newCalls, callsHO, timeHO = callClass(timeInt, callArrT, df['Veh Arr Time'][veh], df['Veh Dep Time'][veh], distr, meanCallD, stdDevCallD, meanCallD2, stdDevCallD2, prob)
                for i in range(4):
                    indexR = row + 1
                    data.at[indexR+i, 'Total New Calls'] = data.at[indexR+i,'Total New Calls'] + newCalls[i]
                    data.at[indexR+i, 'Total HO Calls'] = data.at[indexR+i, 'Total HO Calls'] + callsHO[i]
                    # Recording the HO remaining times
                    width = len(timeHO[i])
                    if width != 0:
                        indTS = np.full((width), indexR+i)
                        dfRTemp = pd.DataFrame(indTS, columns=['Five-Minute Time Interval Index']) # for saving intermediate (per veh) results
                        dfRTemp['(Next BS) Remaining Time'] = timeHO[i]
                        frames = [dfRT, dfRTemp]
                        dfRT = pd.concat(frames)
            frames = [dataRT, dfRT]
            dataRT = pd.concat(frames)
    dataRT = dataRT.assign(Index=range(len(dataRT))).set_index('Index')
    dataRT = dataRT[dataRT['Five-Minute Time Interval Index'] < 1441] # predictions up to 23:55 h Friday
    
    data = data.assign(Index=range(len(data))).set_index('Index')
    data.drop(data.tail(4).index,inplace=True)                        # remove the rows added at the beginning
        
    speedL = data.loc[:, 'Speed (mph)']                       
    
    dataML = pd.DataFrame()
    dataML['Flow (Veh/5 Minutes)'] = data.loc[:, 'Flow (Veh/5 Minutes)']
    dataML['Speed Level'] = speedConv(speedL)
    dataML['Total Number Calls'] = data.loc[:, 'Total New Calls'] 
    dataML = dataML.assign(Index=range(len(dataML))).set_index('Index') 
   
    return dataML, data, dataRT




### Saving of the original and generated data in Excel files
# Change to the dataroot directory that contains the PeMS data
os.chdir(dataRoot)
# Save the current directory
cwd = os.getcwd()
# List all files in there and save the list
files = os.listdir(cwd)


# Set a random seed and save it for reproducability 
now = datetime.datetime.now()
seed = int(now.timestamp())
np.random.seed(seed)


# Read the PeMS files and generate network statistics.
# Save them in 3 dataframes. Then, save these in 3 different Excel sheets
# in a new Excel file with the same name.
for num in range(beginWeek, (endWeek+1)):
    for file in files:
        if file.startswith(str(num)) and file.endswith('.xlsx'):
            print(file)
            dataML, data, dataRT  = dataProcessing(file)
            print("len(dataML) = ", len(dataML))
            os.chdir(outputR)
            with pd.ExcelWriter(file, mode='w', engine = 'openpyxl') as writer: # if apend mode, if_sheet_exists='replace'
                dataML.to_excel(writer, sheet_name='MLData')
                data.to_excel(writer, sheet_name='Data')
                dataRT.to_excel(writer, sheet_name='RemainingTime', index=False)
            os.chdir(dataRoot)

os.chdir(outputR)
### Save the input values used for generating the data into an yaml file
# ruamel.yaml.representer.RepresenterError: cannot represent an object: 1.7320508075688772
# Hence, the standard deviation values are first converted into strings:
argsDict['standardDeviationCallDuration'] = str(stdDevCallD)
argsDict['standardDeviationCallDuration2'] = str(stdDevCallD2)
argsDict['seed'] = seed
argsDict['date and time'] = now

# Saving
print("Saving the input values into an yaml file.")
print('ArgsDict', argsDict)
with open('input_data_values.yml', 'w') as f:
    yaml.dump(argsDict, f)
